## [36. Valid Sudoku](https://leetcode.com/problems/valid-sudoku/)
**Difficulty:** Medium | **Topic:** Hash Set

### Approach 1: Hash Set
#### Intuition
We can validate a Suduko board in **one single pass** by checking for each cell if a digit has already appeared in:
1. the same row
2. the same column
3. the same 3×3 box
We track these using three hash sets:
1. rows[r] keeps digits seen in row r
2. cols[c] keeps digits seen in column c
3. squares[(r // 3, c // 3)] keeps digits in the 3×3 box
If a digit appears again in any of these places, the board is invalid.

#### Algorithm
1. Create three hash maps of sets:
- `rows` to track digits in each row
- `cols` to track digits in each column
- `squares` to track digits in each 3×3 sub-box, keyed by `(r // 3, c // 3)`
- Note: The hash maps will be a `defaultdict(set)` to create a new list to the corresponding row, col, or square

2. Use a nested loop to pass through every cell in the board.
- Skip (`continue`) the pass if the cell is empty (`'.'`)
- Let `val` be the digit in the cell
- Check if `val` is in any of the hash maps we have to the corresponding row (`row[r]`), col (`col[c]`), or square (`sqaure[(r//3, c//3)]`)
    - if `val` is in any of the hash maps, return `False` as it is not a vaild sudoku

3. Add the digit into the corresponding hash maps before moving into the next loop/cell
- `rows[r].add(val)`
- `cols[c].add(val)`
- `squares[(r // 3, c // 3)].add(val)`

4. If passed through the whole sudoko board, not have not found duplicates in the hash map, return `True`

#### Complexity
* **Time:** $O({n}^2)$: Where $n$ is the side length of the board
* **Space:** $O(3{n}^2) = O({n}^2)$: Where Total Space= Space(rows)+Space(cols)+Space(squares) = ${n}^2 + {n}^2 + {n}^2 = 3{n}^2 = {n}^2$

#### Code
```python
class Solution:
    def isValidSudoku(self, board: List[List[str]]) -> bool:

        rows = defaultdict(set)
        cols = defaultdict(set)
        squares = defaultdict(set)

        for r in range(9):
            for c in range(9):
                val = board[r][c]   
                if val == '.':
                    continue
                if (
                    val in rows[r] or
                    val in cols[c] or
                    val in squares[(r // 3, c // 3)]
                ):
                    return False

                rows[r].add(val)
                cols[c].add(val)
                squares[(r // 3, c // 3)].add(val)
                
        return True
```
