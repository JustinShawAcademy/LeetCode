## 167. [Two Sum II - Input Array Is Sorted](https://leetcode.com/problems/two-sum-ii-input-array-is-sorted/description/)
**Difficulty:** Medium | **Topic:** Two Pointers

### Approach 1: Two Pointers (Optimal) 
#### Intuition
Since the given array is sorted, we can use two pointers to adjust the sum and converge into `target`. If the current sum is too small, we shift the left pointer to the right so that current sum is bigger. If the current sum is too big, we left the right pointer to the left so that current sum is smaller

[IMPORTANT]
By looking at the constraint: `2 <= numbers.length <= 3 * 10^4`, a brute force solution with $O({n}^2)$ time would not be viable at all because of the possibility of getting TLE (Time Limit Exceded). Therefore just by looking at the constraint, we can conclude that our solution should be of $O(N log N)$ or $O(N)$ time.

In cases where $O({n}^2)$ would be okay, is when the constraint is $n â‰¤ 100$ for example. 

#### Algorithm
1. Initalize the pointers.
    - l = 0 (starting index of array)
    - r = len(numbers) - 1 (ending index of array)
2. `while l < r` (When l and r cross, there are no candidates left that satisfy the constraints of the problem)
    - Compute the current sum: `currSum = numbers[l] + numbers[r]
    - If `target > currSum`: move `l` up by `1` to increase `currSum`
    - If `target < currSum`: move `r` down by `1` to decrease `currSum`
    - If `target == currSum`: return [l + 1, r + 1]

#### Complexity
* **Time:** $O(n)$
* **Space:** $O(1)$

#### Code
```python
class Solution:
    def twoSum(self, numbers: List[int], target: int) -> List[int]:

        l, r = 0, len(numbers) - 1

        # When l and r cross, there are no candidates left that satisfy the constraints of the problem
        while l < r:
            currSum = numbers[l] + numbers[r] 
            if target > currSum:
                l += 1
            elif target < currSum: 
                r -= 1
            else:
                return [l + 1, r + 1]
```