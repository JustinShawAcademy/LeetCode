## [347. Top K Frequent Elements](https://leetcode.com/problems/top-k-frequent-elements/description/)
*  Medium Problem



### Solution
#### Min-Heap (Intuition)
**Part 1: Counting Frequencies** <br>
We simply count the frequencies found in the given list `nums`. The keys will be the numbers, and the values will be their frequencies.

```py
count = {}
for n in nums:
    count[n] = 1 + count.get(n, 0)
```

**Part 2: Using the Min Heap (`heapq`)** 

What is a Min Heap? <br>
A data structure that's great at keeping track of the smallest item in a collection. Imagine it as a special kind of list where the smallest element is always at the front (position 0), ready to be accessed instantly.

- `heapq.heappush(heap, item)`: Adds an `item` to the `heap` while maintaining the "smallest-on-top" property.

- `heapq.heappop(heap)`: Removes and returns the smallest `item` from the `heap`.

```py
heap = []
for num, freq in count.items():
    heapq.heappush(heap, (freq, num))
    if len(heap) > k:
        heapq.heappop(heap)
```

1. `heap = []`: We initialize an empty list that the `heapq` module will manage as a min heap.
2. `for num in count.keys()`: We loop through the unique numbers we counted earlier.
3. `heapq.heappush(heap, (freq, num))`: We push a tuple `(frequency, number)` onto the heap. Python's heap will automatically use the first element of the tuple (the frequency) for comparison.
4. `if len(heap) > k`: We check if our heap has grown too large (more elements than `k`).
5. `heapq.heappop(heap)`: If the heap is too large, we pop the smallest element. This removes the number with the lowest frequency from our set of `k+1` candidates, ensuring that the heap always contains the top `k` most frequent elements seen so far.

**Part 3: Extracting the Final Result** <br>
The heap now holds our answer, but in tuple format (frequency, number). We just need to pull out the numbers.
```py
return [num for freq, num in heap]
```



#### Min-Heap (Solution)
```py
class Solution:
    def topKFrequent(self, nums: List[int], k: int) -> List[int]:
        
        ### Part 1: Counting Frequencies
        count = {}
        for n in nums:
            count[n] = 1 + count.get(n, 0)

        ### Part 2: Using the Min Heap (heapq)
        heap = []
        for num, freq in count.items():
            heapq.heappush(heap, (freq, num))
            if len(heap) > k:
                heapq.heappop(heap)

        ### Part 3. Extracting the Final Result
        return [num for freq, num in heap]
            
```
##### Time & Space Complexity
* Time complexity: $O(Nlogk)$
* Space complexity: $O(n+k)$
> Where $n$ is the length of the array and $k$ is the number of top frequent elements.  



